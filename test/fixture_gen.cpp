//
// Created by matthew on 4/20/25.
//

#include <iostream>
#include <string>
#include <vector>

#include "CLI/CLI.hpp"
#include "fileio.h"
#include "parser.h"
#include "tokenizer.h"


/**
 * Gets the base name of a file with the path and extension stripped off
 * @param filePath The original file path
 * @return
 */
std::string getBaseFileName(const std::string& filePath) {
    // Find the last occurrence of the directory separator (slash or backslash)
    const size_t sepPos = filePath.find_last_of(std::filesystem::path::preferred_separator);
    const std::string baseFile =
            sepPos == std::string::npos ? filePath : filePath.substr(sepPos + 1);
    // Find the last occurrence of the dot, marking the extension
    const std::string fileName = baseFile.substr(0, baseFile.find_last_of('.'));
    return fileName;
}


/**
 * Writes a tokenized representation of the given program lines to the given file handle
 * @param tokenFile The file handle to write to
 * @param lines The lines of the program to write
 * @param mangleId The ID to mangle the labels with
 * @return The tokenized representation of the program lines as a vector of vectors
 */
std::vector<std::vector<Token>> genTokenFile(std::ofstream& tokenFile,
                                             const std::vector<std::string>& lines,
                                             const std::string& mangleId) {
    Tokenizer tokenizer{};
    const std::vector<std::vector<Token>> tokenizedLines = tokenizer.tokenize(lines, mangleId);
    for (const std::vector<Token>& tokenLine : tokenizedLines) {
        for (const Token& token : tokenLine) {
            constexpr unsigned char groupSep = 0x1d;
            std::string tokenType = std::to_string(static_cast<int>(token.type));
            if (static_cast<int>(token.type) < 10)
                tokenType.insert(0, "0");

            tokenFile << tokenType << token.value << groupSep;
        }
        tokenFile << std::endl;
    }

    return tokenizedLines;
}


/**
 * Writes a parser representation of the given tokenized lines to the given file handle
 * @param parserFile The file handle to write to
 * @param tokenizedLines The tokenized lines to parse
 * @return The memory layout generated by the parser
 */
MemLayout generateParserFile(std::ofstream& parserFile,
                             const std::vector<std::vector<Token>>& tokenizedLines) {
    Parser parser{};
    MemLayout memLayout = parser.parse(tokenizedLines);

    for (const std::pair<const MemSection, std::vector<std::byte>>& pair : memLayout) {
        constexpr unsigned char groupSep = 0x1d;
        parserFile << groupSep << static_cast<unsigned char>(pair.first);
        for (const std::byte byte : pair.second)
            parserFile << static_cast<unsigned char>(byte);
    }

    return memLayout;
}


int main(const int argc, char* argv[]) {

    std::string inputFileName;
    std::string mangleId;

    CLI::App app{"masm Intermediate Generator", "masm-fg"};
    app.add_option("input-file", inputFileName, "Input file to load")->required();
    // Allows name mangling
    app.add_option("--mangle-id", mangleId, "Name mangling ID")->default_str("");

    try {
        app.parse(argc, argv);
    } catch (const CLI::ParseError& e) {
        return app.exit(e);
    }

    try {
        const std::string baseFileName = getBaseFileName(inputFileName);

        std::ofstream tokenFile;
        tokenFile.open(baseFileName + ".tkn");
        if (!tokenFile.is_open())
            throw std::runtime_error("Could not open file " + baseFileName + ".tkn");
        std::ofstream parserFile;
        parserFile.open(baseFileName + ".pse");
        if (!parserFile.is_open())
            throw std::runtime_error("Could not open file " + baseFileName + ".pse");

        const std::vector<std::string> lines = readFileLines(inputFileName);

        const std::vector<std::vector<Token>> tokenizedLines =
                genTokenFile(tokenFile, lines, mangleId);
        MemLayout memLayout = generateParserFile(parserFile, tokenizedLines);

        tokenFile.close();
        parserFile.close();
    } catch (const std::exception& e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }

    return 0;
}
